from flask import current_app, jsonify, request, send_from_directory, abort
from .models import Media, Tag # Assuming db is available via current_app.extensions['sqlalchemy'].db
from app.tag_manager import get_all_global_tags # Corrected import path
import os

# Helper to get db session
def get_db():
    return current_app.extensions['sqlalchemy'].db

@current_app.route('/')
def index():
    # This will eventually serve the main HTML page
    return "Hello, Photo Album Manager! API is under /api"

@current_app.route('/api/media', methods=['GET'])
def list_media():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    sort_by = request.args.get('sort_by', 'capture_time', type=str) # 'capture_time', 'modification_time', 'filepath'
    sort_order = request.args.get('sort_order', 'desc', type=str) # 'asc', 'desc'

    query = Media.query

    # Sorting logic
    order_column = Media.capture_time # Default
    if sort_by == 'modification_time':
        order_column = Media.modification_time
    elif sort_by == 'filepath':
        order_column = Media.filepath
    elif sort_by == 'filename':
        order_column = Media.filename
    elif sort_by == 'filesize':
        order_column = Media.filesize

    if sort_order.lower() == 'asc':
        query = query.order_by(order_column.asc())
    else:
        query = query.order_by(order_column.desc())

    paginated_media = query.paginate(page=page, per_page=per_page, error_out=False)

    media_list = []
    for item in paginated_media.items:
        media_list.append({
            'id': item.id,
            'filepath': item.filepath,
            'filename': item.filename,
            'org_path': item.org_path,
            'capture_time': item.capture_time.isoformat() if item.capture_time else None,
            'modification_time': item.modification_time.isoformat() if item.modification_time else None,
            'filesize': item.filesize,
            'media_type': item.media_type,
            'tags': [tag.name for tag in item.tags]
        })

    return jsonify({
        'media': media_list,
        'total_pages': paginated_media.pages,
        'current_page': paginated_media.page,
        'total_items': paginated_media.total
    })

@current_app.route('/api/tags', methods=['GET'])
def list_tags():
    tags = get_all_global_tags()
    return jsonify([{'id': tag.id, 'name': tag.name} for tag in tags])

@current_app.route('/api/org_paths', methods=['GET'])
def list_org_paths():
    # ORG_PATHS are loaded from config.py into current_app.config
    org_paths = current_app.config.get('ORG_PATHS', [])
    return jsonify(org_paths)

# Endpoint to serve original media files
# Note: For large files or production, consider using a dedicated file server or X-Accel-Redirect with Nginx.
@current_app.route('/api/media/file/<int:media_id>', methods=['GET'])
def get_media_file(media_id):
    media_item = Media.query.get_or_404(media_id)
    # Security check: Ensure the filepath is within a configured ORG_PATH to prevent arbitrary file access.
    # This is a basic check. More robust validation might be needed depending on how ORG_PATHS are structured.
    is_safe_path = False
    abs_filepath = os.path.abspath(media_item.filepath)
    for org_path in current_app.config.get('ORG_PATHS', []):
        if abs_filepath.startswith(os.path.abspath(org_path)):
            is_safe_path = True
            break

    if not is_safe_path:
        abort(403) # Forbidden

    if not os.path.exists(media_item.filepath):
        abort(404) # Not found

    directory = os.path.dirname(media_item.filepath)
    filename = os.path.basename(media_item.filepath)
    return send_from_directory(directory, filename)

# Placeholder for thumbnail serving - will be implemented properly in the next step
@current_app.route('/api/media/thumbnail/<int:media_id>', methods=['GET'])
def get_media_thumbnail(media_id):
    # This will be enhanced in Step 6: Thumbnail Generation
    # For now, it could either return a placeholder or attempt to serve a small version if available
    # Or, to avoid breaking, just return 404 or a message.
    media_item = Media.query.get_or_404(media_id)
    # current_app.config.get('BASE_DIR') should be /app/photo_album_manager/photo_album_manager
    thumbnail_dir = os.path.join(current_app.config.get('BASE_DIR', '.'), 'data', 'thumbnails')
    # Example thumbnail filename: {media_id}_{filename_part}.jpg (actual naming TBD)
    # This is just a placeholder path construction
    potential_thumb_name = f"{media_item.id}_thumb.jpg"
    thumbnail_path = os.path.join(thumbnail_dir, potential_thumb_name)

    if os.path.exists(thumbnail_path):
         # Similar safety check as for original files might be needed if thumbnails are not in a public static dir
        return send_from_directory(thumbnail_dir, potential_thumb_name)
    else:
        # In future, could trigger thumbnail generation here or return placeholder
        # For now, let's try to serve the original if no thumbnail and it's an image,
        # or 404 if not (simplistic for now).
        if media_item.media_type == 'image':
            return get_media_file(media_id) # Fallback to original for now for images
        else:
            return jsonify({'message': 'Thumbnail not available for this media type or not generated yet.'}), 404
