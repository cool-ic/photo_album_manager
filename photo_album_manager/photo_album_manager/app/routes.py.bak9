from flask import current_app, jsonify, request, send_from_directory, abort, render_template, session
from .models import db, Media, Tag
from app.tag_manager import get_all_global_tags, add_global_tag, delete_global_tag, add_tags_to_media # Import add_tags_to_media
from app.image_utils import generate_thumbnail, get_thumbnail_path
from app.utils import execute_user_filter_function
from app.scanner import scan_libraries
import os
import logging
import traceback

routes_logger = logging.getLogger(__name__ + '.routes')
if not routes_logger.handlers:
    handler = logging.StreamHandler()
    formatter = logging.Formatter('%(asctime)s - ROUTES - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    routes_logger.addHandler(handler)
    routes_logger.setLevel(logging.DEBUG)
    # routes_logger.propagate = False # Optional

@current_app.route('/')
def index_page():
    return render_template('index.html')

@current_app.route('/api/scan/trigger', methods=['POST'])
def trigger_scan_endpoint():
    routes_logger.info("POST /api/scan/trigger - Scan trigger endpoint called.")
    try:
        routes_logger.info("Calling scan_libraries()...")
        scan_libraries()
        routes_logger.info("scan_libraries() completed successfully via API trigger.")
        return jsonify({'message': 'Library scan initiated and completed successfully.'}), 200
    except Exception as e:
        detailed_error = traceback.format_exc()
        routes_logger.error(f"Error during API triggered scan: {e}\n{detailed_error}")
        return jsonify({'error': 'An error occurred during the library scan.', 'details': str(e), 'trace': detailed_error}), 500

@current_app.route('/api/media/filter_config', methods=['POST', 'DELETE'])
def media_filter_config():
    if request.method == 'POST':
        data = request.get_json()
        if not data or 'filter_code' not in data:
            routes_logger.warning("/api/media/filter_config POST: Missing filter_code")
            return jsonify({'error': 'Missing filter_code in request body'}), 400

        filter_code = data['filter_code']
        if 'def api_select(media):' not in filter_code:
             routes_logger.warning(f"POST /api/media/filter_config: 'def api_select(media):' not found in submitted code: {filter_code[:150]}...")
             return jsonify({'error': 'Filter code must contain "def api_select(media):"'}), 400

        session['media_filter_code'] = filter_code
        routes_logger.info(f"Saved new media_filter_code to session: {filter_code[:100]}...")
        return jsonify({'message': 'Filter configuration saved.'}), 200
    elif request.method == 'DELETE':
        removed_filter = session.pop('media_filter_code', None)
        if removed_filter:
            routes_logger.info("Cleared media_filter_code from session.")
        else:
            routes_logger.info("Attempted to clear media_filter_code, but none was set.")
        return jsonify({'message': 'Filter configuration cleared.'}), 200

@current_app.route('/api/media', methods=['GET'])
def list_media():
    page = request.args.get('page', 1, type=int)
    per_page_arg = request.args.get('per_page', 20, type=int)
    sort_by = request.args.get('sort_by', 'capture_time', type=str)
    sort_order = request.args.get('sort_order', 'desc', type=str)
    routes_logger.debug(f"/api/media GET request: page={page}, per_page={per_page_arg}, sort_by='{sort_by}', sort_order='{sort_order}'")
    query = Media.query
    order_column_map = {
        'capture_time': Media.capture_time, 'modification_time': Media.modification_time,
        'filepath': Media.filepath, 'filename': Media.filename, 'filesize': Media.filesize
    }
    order_column = order_column_map.get(sort_by, Media.capture_time)
    query = query.order_by(order_column.asc() if sort_order.lower() == 'asc' else order_column.desc())
    user_filter_code = session.get('media_filter_code')
    all_items_from_db = query.all()
    filtered_items = []
    if user_filter_code:
        routes_logger.info(f"Applying user filter from session. Code starts with: {user_filter_code[:100]}...")
        routes_logger.debug(f"Number of items before filtering: {len(all_items_from_db)}")
        for item in all_items_from_db:
            media_dict_for_filter = {
                'tag': [t.name for t in item.tags], 'org_PATH': item.org_path,
                'filename': item.filename, 'filepath': item.filepath,
                'capture_time': item.capture_time.isoformat() if item.capture_time else None,
                'modification_time': item.modification_time.isoformat() if item.modification_time else None,
                'filesize': item.filesize, 'media_type': item.media_type, 'id': item.id
            }
            if execute_user_filter_function(media_dict_for_filter, user_filter_code):
                filtered_items.append(item)
        routes_logger.info(f"Number of items after filtering: {len(filtered_items)}")
    else:
        routes_logger.debug("No user filter in session. Using all items from DB query.")
        filtered_items = all_items_from_db
    total_items = len(filtered_items)
    start_index = (page - 1) * per_page_arg
    end_index = start_index + per_page_arg
    paginated_slice = filtered_items[start_index:end_index]
    total_pages = (total_items + per_page_arg - 1) // per_page_arg if per_page_arg > 0 else 0
    if total_items == 0: total_pages = 0
    routes_logger.debug(f"Pagination: total_items={total_items}, page={page}, per_page={per_page_arg}, returning {len(paginated_slice)} items for this page.")
    media_list_response = [
        {'id': s.id, 'filepath': s.filepath, 'filename': s.filename, 'org_path': s.org_path,
         'capture_time': s.capture_time.isoformat() if s.capture_time else None,
         'modification_time': s.modification_time.isoformat() if s.modification_time else None,
         'filesize': s.filesize, 'media_type': s.media_type, 'tags': [t.name for t in s.tags]}
        for s in paginated_slice
    ]
    return jsonify({'media': media_list_response, 'total_pages': total_pages, 'current_page': page, 'total_items': total_items})

@current_app.route('/api/tags', methods=['GET', 'POST'])
def manage_tags_endpoint():
    if request.method == 'GET':
        routes_logger.debug("/api/tags GET request")
        tags = get_all_global_tags()
        return jsonify([{'id': tag.id, 'name': tag.name} for tag in tags])

    if request.method == 'POST':
        routes_logger.debug("/api/tags POST request for adding new tag")
        data = request.get_json()
        if not data or not data.get('name'):
            routes_logger.warning("/api/tags POST: Missing 'name' in request body for new tag.")
            return jsonify({'error': 'Tag name is required.'}), 400

        tag_name = data['name'].strip()
        if not tag_name:
            routes_logger.warning("/api/tags POST: Tag name cannot be empty after stripping.")
            return jsonify({'error': 'Tag name cannot be empty.'}), 400

        routes_logger.info(f"Attempting to add global tag: '{tag_name}'")
        tag_object = add_global_tag(tag_name)

        if tag_object:
            routes_logger.info(f"Tag '{tag_object.name}' (ID: {tag_object.id}) processed successfully by add_global_tag.")
            return jsonify({'id': tag_object.id, 'name': tag_object.name}), 200
        else:
            routes_logger.error(f"add_global_tag returned None for tag_name: '{tag_name}', indicating an internal server issue.")
            return jsonify({'error': 'Failed to add tag due to an internal server issue.'}), 500

@current_app.route('/api/tags/<int:tag_id>', methods=['DELETE'])
def delete_tag_endpoint(tag_id):
    routes_logger.info(f"DELETE /api/tags/{tag_id} - Attempting to delete tag with ID: {tag_id}")
    tag_to_delete = Tag.query.get(tag_id)

    if not tag_to_delete:
        routes_logger.warning(f"Tag with ID {tag_id} not found for deletion.")
        return jsonify({'error': 'Tag not found.'}), 404

    tag_name = tag_to_delete.name

    if delete_global_tag(tag_name):
        routes_logger.info(f"Successfully deleted tag '{tag_name}' (ID: {tag_id}).")
        return jsonify({'message': f"Tag '{tag_name}' deleted successfully."}), 200
    else:
        routes_logger.error(f"Failed to delete tag '{tag_name}' (ID: {tag_id}) via tag_manager function.")
        return jsonify({'error': 'Failed to delete tag due to an internal issue or tag was already removed.'}), 500

@current_app.route('/api/media/<int:media_id>/tags', methods=['POST'])
def add_tags_to_media_item_endpoint(media_id):
    routes_logger.info(f"POST /api/media/{media_id}/tags - Attempting to add tags.")
    data = request.get_json()
    if not data or 'tag_names' not in data or not isinstance(data['tag_names'], list):
        routes_logger.warning(f"Add tags to media {media_id}: Invalid payload. 'tag_names' list is required.")
        return jsonify({'error': "Invalid payload. 'tag_names' must be a list of strings."}), 400

    tag_names_list = [str(name).strip() for name in data['tag_names'] if str(name).strip()]

    if not tag_names_list and data['tag_names']: # If original list was not empty but all stripped to empty
        routes_logger.warning(f"Add tags to media {media_id}: Provided tag names list contained only empty or whitespace strings.")
        return jsonify({'error': 'Tag names cannot be empty or just whitespace.'}), 400
    if not tag_names_list and not data['tag_names']: # If original list was empty
         routes_logger.info(f"Add tags to media {media_id}: Empty tag_names list provided. No tags to add.")
         # It's not an error to add no tags, just means no operation.
         # Return current tags of media item.
         media_item_for_current_tags = Media.query.get(media_id)
         if not media_item_for_current_tags:
             return jsonify({'error': 'Media item not found.'}), 404
         current_tags = [tag.name for tag in media_item_for_current_tags.tags]
         return jsonify({'message': 'No valid tags provided to add.', 'media_id': media_id, 'tags': current_tags}), 200


    media_item = Media.query.get(media_id)
    if not media_item:
        routes_logger.warning(f"Add tags to media {media_id}: Media item not found.")
        return jsonify({'error': 'Media item not found.'}), 404

    routes_logger.info(f"Calling add_tags_to_media for media_id={media_id} with tags: {tag_names_list}")
    success = add_tags_to_media(media_id, tag_names_list) # This function is in app.tag_manager

    if success:
        updated_media_item = Media.query.get(media_id) # Re-fetch to get updated tags
        current_tags = [tag.name for tag in updated_media_item.tags]
        routes_logger.info(f"Tags successfully added/updated for media ID {media_id}. Current tags: {current_tags}")
        return jsonify({'message': 'Tags added successfully.', 'media_id': media_id, 'tags': current_tags}), 200
    else:
        # This typically means media_id was not found, which is checked above,
        # or an internal error occurred in add_tags_to_media.
        routes_logger.error(f"add_tags_to_media failed for media ID {media_id} with tags {tag_names_list}.")
        return jsonify({'error': 'Failed to add tags to media item due to an internal issue.'}), 500

@current_app.route('/api/org_paths', methods=['GET'])
def list_org_paths():
    org_paths = current_app.config.get('ORG_PATHS', [])
    return jsonify(org_paths)

@current_app.route('/api/media/file/<int:media_id>', methods=['GET'])
def get_media_file(media_id):
    media_item = Media.query.get_or_404(media_id)
    is_safe_path = any(os.path.abspath(media_item.filepath).startswith(os.path.abspath(p)) for p in current_app.config.get('ORG_PATHS', []))
    if not is_safe_path: abort(403)
    if not os.path.exists(media_item.filepath): abort(404)
    return send_from_directory(os.path.dirname(media_item.filepath), os.path.basename(media_item.filepath))

@current_app.route('/api/media/thumbnail/<int:media_id>', methods=['GET'])
def get_media_thumbnail(media_id):
    media_item = Media.query.get_or_404(media_id)
    if media_item.media_type != 'image': return jsonify({'message': 'Thumbnails only available for images.'}), 404
    thumb_full_path, thumb_dir, thumb_filename = get_thumbnail_path(media_item.id)
    if not os.path.exists(thumb_full_path):
        generated_path = generate_thumbnail(media_item)
        if not generated_path: return jsonify({'message': 'Thumbnail generation failed.'}), 500
    expected_thumb_base = os.path.join(current_app.config.get('BASE_DIR', ''), 'data', 'thumbnails')
    if not os.path.abspath(thumb_dir).startswith(os.path.abspath(expected_thumb_base)):
        routes_logger.error(f"Thumbnail path {thumb_dir} is outside expected base {expected_thumb_base}.")
        abort(403)
    return send_from_directory(thumb_dir, thumb_filename)
