from flask import current_app, jsonify, request, send_from_directory, abort, render_template, session
from .models import db, Media, Tag
# Ensure set_tags_for_media is NOT imported
from app.tag_manager import get_all_global_tags, add_global_tag, delete_global_tag, add_tags_to_media
from app.image_utils import generate_thumbnail, get_thumbnail_path
from app.utils import execute_user_filter_function
from app.scanner import scan_libraries
import os, logging, traceback

routes_logger = logging.getLogger('photo_album_manager.routes') # Use fixed name
if not routes_logger.handlers:
    h = logging.StreamHandler();
    h.setFormatter(logging.Formatter('%(asctime)s - ROUTES - %(levelname)s - %(message)s'));
    routes_logger.addHandler(h);
    routes_logger.setLevel(logging.DEBUG)
    routes_logger.propagate = False

@current_app.route('/')
def index_page(): return render_template('index.html')

@current_app.route('/api/scan/trigger', methods=['POST'])
def trigger_scan_endpoint():
    routes_logger.info("POST /api/scan/trigger called.")
    try:
        scan_libraries();
        routes_logger.info("API: Scan completed successfully.")
        return jsonify({'message': 'Scan completed.'}), 200
    except Exception as e:
        routes_logger.error(f'API Scan error: {e}', exc_info=True);
        return jsonify({'error': str(e), 'trace': traceback.format_exc()}), 500

@current_app.route('/api/media/filter_config', methods=['POST', 'DELETE'])
def media_filter_config():
    if request.method == 'POST':
        data = request.get_json();
        if not data or 'filter_code' not in data:
            routes_logger.warning("Filter config POST missing 'filter_code'.")
            return jsonify({'error': 'Missing filter_code'}), 400
        if 'def api_select(media):' not in data['filter_code']:
            routes_logger.warning("Filter code POST missing 'def api_select(media):'.")
            return jsonify({'error': 'Filter code must contain "def api_select(media):"'}), 400
        session['media_filter_code'] = data['filter_code'];
        routes_logger.info(f"Filter code updated in session (len: {len(data['filter_code'])}).")
        return jsonify({'message': 'Filter configuration saved.'})
    elif request.method == 'DELETE':
        session.pop('media_filter_code', None);
        routes_logger.info("Filter code cleared from session.")
        return jsonify({'message': 'Filter configuration cleared.'})

@current_app.route('/api/media', methods=['GET'])
def list_media():
    page=request.args.get('page',1,type=int);per_page_arg=request.args.get('per_page',20,type=int);
    sort_by=request.args.get('sort_by','capture_time',type=str);sort_order=request.args.get('sort_order','desc',type=str);
    routes_logger.debug(f"GET /api/media: page={page}, per_page={per_page_arg}, sort_by='{sort_by}', sort_order='{sort_order}'")
    q=Media.query;
    om={'capture_time':Media.capture_time,'modification_time':Media.modification_time,'filepath':Media.filepath,'filename':Media.filename,'filesize':Media.filesize}; # Shortened key for map
    oc=om.get(sort_by,Media.capture_time); # Default to capture_time if sort_by is invalid
    q=q.order_by(oc.asc() if sort_order.lower()=='asc' else oc.desc());
    ufc=session.get('media_filter_code');db_items=q.all();fi=[];
    if ufc:
        routes_logger.info(f"Applying user filter to {len(db_items)} items. Filter starts: {ufc[:100]}...")
        for i in db_items:
            md={'tag':[t.name for t in i.tags],'org_PATH':i.org_path,'filename':i.filename,'filepath':i.filepath,'capture_time':i.capture_time.isoformat() if i.capture_time else None,'modification_time':i.modification_time.isoformat() if i.modification_time else None,'filesize':i.filesize,'media_type':i.media_type,'id':i.id};
            if execute_user_filter_function(md,ufc): fi.append(i)
        routes_logger.info(f"Filter resulted in {len(fi)} items.")
    else:
        routes_logger.debug("No user filter in session."); fi=db_items
    ti=len(fi);si=(page-1)*per_page_arg;ei=si+per_page_arg;ps=fi[si:ei];
    tp=(ti+per_page_arg-1)//per_page_arg if per_page_arg>0 else 0
    if ti == 0: tp = 0; # Ensure total_pages is 0 if no items
    routes_logger.debug(f"Pagination: total_items={ti}, page={page}, per_page={per_page_arg}, returning {len(ps)} items.")
    mlr=[{'id':s.id,'filepath':s.filepath,'filename':s.filename,'org_path':s.org_path,'capture_time':s.capture_time.isoformat() if s.capture_time else None,'modification_time':s.modification_time.isoformat() if s.modification_time else None,'filesize':s.filesize,'media_type':s.media_type,'tags':[t.name for t in s.tags]} for s in ps];
    return jsonify({'media':mlr,'total_pages':tp,'current_page':page,'total_items':ti})

@current_app.route('/api/tags', methods=['GET', 'POST'])
def manage_tags_endpoint():
    if request.method == 'GET':
        routes_logger.debug("GET /api/tags")
        return jsonify([{'id': t.id, 'name': t.name} for t in get_all_global_tags()])
    if request.method == 'POST':
        routes_logger.debug("POST /api/tags")
        d=request.get_json();
        if not d or not d.get('name'): routes_logger.warning("POST /api/tags: Missing 'name'."); return jsonify({'error': 'Tag name required.'}), 400
        n=d.get('name','').strip();
        if not n: routes_logger.warning("POST /api/tags: Empty tag name."); return jsonify({'error': 'Tag name cannot be empty.'}), 400
        to=add_global_tag(n);
        if to: routes_logger.info(f"Tag '{to.name}' (ID: {to.id}) processed via POST /api/tags."); return jsonify({'id':to.id,'name':to.name})
        else: routes_logger.error(f"Failed to add/retrieve tag '{n}' via POST /api/tags."); return jsonify({'error':'Failed to add tag.'}),500

@current_app.route('/api/tags/<int:tag_id>', methods=['DELETE'])
def delete_tag_endpoint(tag_id):
    routes_logger.info(f"DELETE /api/tags/{tag_id}")
    t=Tag.query.get(tag_id);
    if not t: routes_logger.warning(f"Tag ID {tag_id} not found for DELETE."); return jsonify({'error': 'Tag not found.'}), 404
    tag_name_for_log = t.name
    if delete_global_tag(tag_name_for_log):
        routes_logger.info(f"Tag '{tag_name_for_log}' (ID: {tag_id}) deleted.")
        return jsonify({'message':f"Tag '{tag_name_for_log}' deleted."})
    else:
        routes_logger.error(f"Failed to delete tag '{tag_name_for_log}' (ID: {tag_id}) via tag_manager.")
        return jsonify({'error':'Failed to delete.'}),500

# Modified: Removed PUT, only POST for adding tags cumulatively
@current_app.route('/api/media/<int:media_id>/tags', methods=['POST'])
def add_media_item_tags_endpoint(media_id): # Renamed from manage_media_item_tags_endpoint
    media_item = Media.query.get(media_id)
    if not media_item:
        routes_logger.warning(f"POST /api/media/{media_id}/tags: Media item not found.")
        return jsonify({'error': 'Media item not found.'}), 404

    data = request.get_json()
    if not data or 'tag_names' not in data or not isinstance(data['tag_names'], list):
        routes_logger.warning(f"POST /api/media/{media_id}/tags: Invalid payload.")
        return jsonify({'error': "Invalid payload. 'tag_names' must be a list."}), 400

    tag_names = [str(name).strip() for name in data['tag_names'] if str(name).strip()]
    routes_logger.info(f"POST /api/media/{media_id}/tags - Adding tags: {tag_names}")

    if not tag_names and data['tag_names']: # Original list was non-empty but all stripped to empty
        routes_logger.warning(f"POST /api/media/{media_id}/tags: No valid tag names after stripping.")
        return jsonify({'error': 'Tag names cannot be empty or just whitespace.'}), 400

    # add_tags_to_media handles empty tag_names list gracefully (returns True, no changes)
    if not add_tags_to_media(media_id, tag_names):
        routes_logger.error(f"Failed to add tags {tag_names} to media ID {media_id} via tag_manager.")
        return jsonify({'error': 'Failed to add tags.'}), 500

    # No need to db.session.refresh(media_item) if add_tags_to_media commits and objects are managed by session.
    # The media_item.tags relationship should be up-to-date.
    updated_tags = [tag.name for tag in media_item.tags]
    routes_logger.info(f"Tags for media ID {media_id} are now: {updated_tags}")
    return jsonify({'message': 'Tags added successfully.', 'media_id': media_id, 'tags': updated_tags}), 200

@current_app.route('/api/org_paths', methods=['GET'])
def list_org_paths(): return jsonify(current_app.config.get('ORG_PATHS',[]))

@current_app.route('/api/media/file/<int:media_id>')
def get_media_file(media_id):
    m=Media.query.get_or_404(media_id);
    if not any(os.path.abspath(m.filepath).startswith(os.path.abspath(p)) for p in current_app.config.get('ORG_PATHS',[])): abort(403)
    if not os.path.exists(m.filepath): abort(404)
    return send_from_directory(os.path.dirname(m.filepath),os.path.basename(m.filepath))

@current_app.route('/api/media/thumbnail/<int:media_id>')
def get_media_thumbnail(media_id):
    m=Media.query.get_or_404(media_id);
    if m.media_type!='image': return jsonify({'message':'Thumbnails for images only.'}),404
    tp,td,tf=get_thumbnail_path(m.id);
    if not os.path.exists(tp):
        gp=generate_thumbnail(m);
        if not gp: return jsonify({'message':'Thumbnail generation failed.'}),500
    etb=os.path.join(current_app.config.get('BASE_DIR',''),'data','thumbnails');
    if not os.path.abspath(td).startswith(os.path.abspath(etb)): routes_logger.error(f"Thumbnail path {td} outside base {etb}."); abort(403)
    return send_from_directory(td,tf)
