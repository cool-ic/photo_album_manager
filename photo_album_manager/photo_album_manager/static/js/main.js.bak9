document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM fully loaded. Initializing application features. Using CSS Grid and dynamic rows.');

    const photoWall = document.getElementById('photo-wall');
    const prevPageBtn = document.getElementById('prev-page');
    const nextPageBtn = document.getElementById('next-page');
    const pageInfoSpan = document.getElementById('page-info');
    const orgPathsList = document.getElementById('org-paths-list');
    const globalTagsList = document.getElementById('global-tags-list');

    const sizeInput = document.getElementById('size-input');
    const sortBySelect = document.getElementById('sort-by');
    const sortOrderSelect = document.getElementById('sort-order');
    const refreshBtn = document.getElementById('refresh-btn');

    // Filter Modal Elements (assuming they exist from previous steps)
    const filterConfigBtn = document.getElementById('filter-config-btn');
    const filterConfigModal = document.getElementById('filter-config-modal');
    const filterFunctionInput = document.getElementById('filter-function-input');
    const applyFilterBtn = document.getElementById('apply-filter-btn');
    const clearFilterBtn = document.getElementById('clear-filter-btn');
    const filterStatusDiv = document.getElementById('filter-status');

    // Image Viewer Modal Elements (assuming they exist)
    const imageViewerModal = document.getElementById('image-viewer-modal');
    const fullImage = document.getElementById('full-image');
    const modalCaption = document.querySelector('.modal-caption');
    const modalPrev = document.querySelector('.modal-prev');
    const modalNext = document.querySelector('.modal-next');

    let currentPage = 1;
    let totalPages = 1;
    let photosPerRow = parseInt(sizeInput.value) || 5;
    photoWall.style.setProperty('--photos-per-row', photosPerRow);

    let currentSortBy = sortBySelect.value;
    let currentSortOrder = sortOrderSelect.value;
    const selectedMediaIds = new Set();
    let currentMediaItems = [];
    let isXKeyPressed = false;
    let resizeTimeout;
    let lastCalculatedPerPage = 0; // To track if perPage needs update on resize

    document.addEventListener('keydown', (event) => { if (event.key === 'x' || event.key === 'X') isXKeyPressed = true; });
    document.addEventListener('keyup', (event) => { if (event.key === 'x' || event.key === 'X') isXKeyPressed = false; });

    function getCalculatedPerPage() {
        const currentPhotosPerRowVal = parseInt(photoWall.style.getPropertyValue('--photos-per-row')) || photosPerRow;
        const wallWidth = photoWall.clientWidth;
        const wallHeight = photoWall.clientHeight;
        const gap = 10; // CSS gap value
        const borderHeightPerItem = 4; // 2px top + 2px bottom border

        if (wallWidth === 0 || wallHeight === 0 || currentPhotosPerRowVal === 0) {
            console.warn("Photo wall dimensions or photosPerRow is zero, using default perPage calculation.");
            return currentPhotosPerRowVal * 4; // Default to 4 rows if dimensions are zero or invalid
        }

        // Calculate width of a single column based on 1fr distribution
        // This width includes the item's content area + its own borders.
        const columnWidth = (wallWidth - (currentPhotosPerRowVal - 1) * gap) / currentPhotosPerRowVal;

        // Since aspect-ratio is 1/1, thumbnail item's total height (content + border) is approx columnWidth.
        const thumbTotalHeight = columnWidth;

        // Height one row of items (including its bottom gap) takes up
        const singleRowWithGapHeight = thumbTotalHeight + gap;

        if (singleRowWithGapHeight <= 0) {
            console.warn("Calculated single row height is zero or negative, using default perPage.");
            return currentPhotosPerRowVal * 4;
        }

        // Calculate how many full rows can fit in the visible height of the photo wall
        const numRows = Math.max(1, Math.floor(wallHeight / singleRowWithGapHeight));
        const calculatedPerPage = currentPhotosPerRowVal * numRows;

        console.log(`Dynamic perPage: wallH=${wallHeight}, photosPerRow=${currentPhotosPerRowVal}, colW/thumbTotalH=${thumbTotalHeight.toFixed(1)}, rowWithGapH=${singleRowWithGapHeight.toFixed(1)}, numRows=${numRows}, perPage=${calculatedPerPage}`);
        return Math.max(currentPhotosPerRowVal, calculatedPerPage); // Ensure at least one row is fetched
    }

    async function fetchMedia(page = 1, sortBy = currentSortBy, sortOrder = currentSortOrder) {
        const calculatedPerPage = getCalculatedPerPage();
        lastCalculatedPerPage = calculatedPerPage; // Store for resize check

        const apiUrl = `/api/media?page=${page}&per_page=${calculatedPerPage}&sort_by=${sortBy}&sort_order=${sortOrder}`;
        console.log(`Fetching media from: ${apiUrl}`);
        try {
            const response = await fetch(apiUrl);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}, message: ${await response.text()}`);
            const data = await response.json();
            console.log('Received media data:', { currentPage: data.current_page, totalPages: data.total_pages, totalItems: data.total_items, itemsInPage: data.media.length });
            currentMediaItems = data.media;
            renderPhotoWall(currentMediaItems);
            currentPage = data.current_page;
            totalPages = data.total_pages;
            updatePaginationControls();
        } catch (error) {
            console.error('Error fetching media:', error);
            photoWall.innerHTML = `<p>Error loading media: ${error.message}. Please try again.</p>`;
        }
    }

    function renderPhotoWall(mediaItems) {
        console.log(`Rendering photo wall with ${mediaItems ? mediaItems.length : 0} items.`);
        photoWall.innerHTML = '';
        if (!mediaItems || mediaItems.length === 0) {
            photoWall.innerHTML = '<p>No media found matching your criteria.</p>';
            return;
        }
        console.log(`Photo wall using CSS Grid with '--photos-per-row': ${photoWall.style.getPropertyValue('--photos-per-row')}`);
        mediaItems.forEach(item => {
            const thumbItem = document.createElement('div');
            thumbItem.classList.add('thumbnail-item');
            thumbItem.dataset.id = item.id;
            thumbItem.style.backgroundImage = `url(/api/media/thumbnail/${item.id})`;
            if (selectedMediaIds.has(item.id)) thumbItem.classList.add('selected');
            thumbItem.addEventListener('click', (event) => {
                if (isXKeyPressed) { event.preventDefault(); openImageViewer(item.id); }
                else { toggleSelection(thumbItem, item.id); }
            });
            photoWall.appendChild(thumbItem);
        });
    }

    sizeInput.addEventListener('change', () => {
        const newSize = parseInt(sizeInput.value);
        if (newSize > 0) {
            console.log(`Size changed to ${newSize} photos per row.`);
            photosPerRow = newSize;
            photoWall.style.setProperty('--photos-per-row', photosPerRow);
            clearSelectionsAndUndoHistory();
            fetchMedia(1);
        } else {
            sizeInput.value = photosPerRow;
        }
    });

    // Debounced resize handler
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            console.log('Window resized, recalculating layout.');
            const newCalculatedPerPage = getCalculatedPerPage();
            if (newCalculatedPerPage !== lastCalculatedPerPage) {
                console.log(`Calculated perPage changed from ${lastCalculatedPerPage} to ${newCalculatedPerPage}. Re-fetching.`);
                clearSelectionsAndUndoHistory();
                fetchMedia(1);
            } else {
                console.log(`Calculated perPage (${newCalculatedPerPage}) same as last (${lastCalculatedPerPage}). No re-fetch needed from resize.`);
            }
        }, 300); // 300ms debounce
    });

    // --- Minified Unchanged functions for brevity ---
    function toggleSelection(thumbElement, mediaId) { if(selectedMediaIds.has(mediaId)){selectedMediaIds.delete(mediaId);thumbElement.classList.remove('selected')}else{selectedMediaIds.add(mediaId);thumbElement.classList.add('selected')}console.log('Current selection IDs:',Array.from(selectedMediaIds)) }
    function updatePaginationControls() { pageInfoSpan.textContent=`Page ${currentPage} of ${totalPages}`;prevPageBtn.disabled=currentPage<=1;nextPageBtn.disabled=currentPage>=totalPages }
    async function fetchOrgPaths() { try {const r=await fetch('/api/org_paths');const d=await r.json();orgPathsList.innerHTML='';d.forEach(p=>{const l=document.createElement('li');l.textContent=p;orgPathsList.appendChild(l)})}catch(e){console.error('Error fetching org paths:',e)} }
    async function fetchGlobalTags() { try {const r=await fetch('/api/tags');const d=await r.json();globalTagsList.innerHTML='';d.forEach(t=>{const l=document.createElement('li');l.textContent=t.name;l.dataset.tagId=t.id;globalTagsList.appendChild(l)})}catch(e){console.error('Error fetching global tags:',e)} }
    sortBySelect.addEventListener('change', () => { currentSortBy = sortBySelect.value; console.log(`Sort by changed to: ${currentSortBy}`); clearSelectionsAndUndoHistory(); fetchMedia(1); });
    sortOrderSelect.addEventListener('change', () => { currentSortOrder = sortOrderSelect.value; console.log(`Sort order changed to: ${currentSortOrder}`); clearSelectionsAndUndoHistory(); fetchMedia(1); });
    refreshBtn.addEventListener('click', async () => { console.log('Deep Refresh button clicked.');const o=refreshBtn.textContent;refreshBtn.textContent='Scanning Libraries...';refreshBtn.disabled=true;let s=false;try{const r=await fetch('/api/scan/trigger',{method:'POST'});const t=await r.json().catch(()=>({error:"Failed to parse response JSON."}));if(!r.ok){console.error('Error triggering scan:',t.error,t.details);alert(`Error triggering library scan: ${t.error||'Unknown error'}`);s=true}else{console.log('Library scan triggered successfully via API.');alert('Library scan complete. Refreshing view.')}}catch(e){console.error('Network error or other issue triggering scan:',e);alert('Failed to trigger library scan. Check network or server console.');s=true}refreshBtn.textContent=o;refreshBtn.disabled=false;if(!s){console.log('Scan successful or error handled, proceeding to refresh view data.');clearSelectionsAndUndoHistory();fetchMedia(1,currentSortBy,currentSortOrder);fetchOrgPaths();fetchGlobalTags()}});
    prevPageBtn.addEventListener('click', () => { if (currentPage > 1) { console.log('Previous page requested.'); clearSelectionsAndUndoHistory(); fetchMedia(currentPage - 1); }});
    nextPageBtn.addEventListener('click', () => { if (currentPage < totalPages) { console.log('Next page requested.'); clearSelectionsAndUndoHistory(); fetchMedia(currentPage + 1); }});
    function clearSelectionsAndUndoHistory() { selectedMediaIds.clear();console.log("FRONTEND: Selections and undo history placeholder cleared.");if(document.readyState==='complete'||document.readyState==='interactive')renderPhotoWall(currentMediaItems); }
    const allModals = document.querySelectorAll('.modal');
    const closeButtons = document.querySelectorAll('.close-modal-btn');
    function openModal(modalId) { const modal = document.getElementById(modalId); if(modal) modal.style.display = 'block'; }
    function closeModal(modalElement) { if(modalElement) modalElement.style.display = 'none'; }
    closeButtons.forEach(button => { button.onclick = function() { closeModal(button.closest('.modal')); }});
    window.onclick = function(event) { allModals.forEach(modal => { if (event.target == modal) closeModal(modal); }); }
    let currentViewIndex = -1;
    function openImageViewer(mediaId) { const itemIndex = currentMediaItems.findIndex(m => m.id === mediaId); if (itemIndex === -1) return; currentViewIndex = itemIndex; updateImageViewerContent(); openModal('image-viewer-modal'); }
    function updateImageViewerContent() { if (currentViewIndex < 0 || currentViewIndex >= currentMediaItems.length) return; const item = currentMediaItems[currentViewIndex]; fullImage.src = `/api/media/file/${item.id}`; modalCaption.textContent = item.filename; modalPrev.style.display = currentViewIndex > 0 ? 'block' : 'none'; modalNext.style.display = currentViewIndex < currentMediaItems.length - 1 ? 'block' : 'none'; }
    modalPrev.onclick = () => { if(currentViewIndex > 0) { currentViewIndex--; updateImageViewerContent(); }};
    modalNext.onclick = () => { if(currentViewIndex < currentMediaItems.length - 1) { currentViewIndex++; updateImageViewerContent(); }};
    document.addEventListener('keydown', (event) => { if (imageViewerModal.style.display === 'block') { if (event.key === 'ArrowLeft') modalPrev.click(); else if (event.key === 'ArrowRight') modalNext.click(); else if (event.key === 'Escape') closeModal(imageViewerModal); }});
    filterConfigBtn.onclick = () => { console.log('Filter config modal opened.'); filterStatusDiv.textContent = ''; filterStatusDiv.style.color = ''; openModal('filter-config-modal'); };
    applyFilterBtn.addEventListener('click', async () => { const filterCode = filterFunctionInput.value; console.log('Applying filter with code:', filterCode.substring(0,100) + '...'); try { const response = await fetch('/api/media/filter_config', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filter_code: filterCode }) }); const result = await response.json(); if (response.ok) { filterStatusDiv.textContent = 'Filter applied successfully!'; filterStatusDiv.style.color = 'green'; console.log('Filter applied successfully via API.'); closeModal(filterConfigModal); clearSelectionsAndUndoHistory(); fetchMedia(1); } else { filterStatusDiv.textContent = `Error: ${result.error || 'Could not apply filter.'}`; filterStatusDiv.style.color = 'red'; console.error('API error applying filter:', result.error); } } catch (error) { console.error('Network error applying filter:', error); filterStatusDiv.textContent = 'Network error applying filter.'; filterStatusDiv.style.color = 'red'; } });
    clearFilterBtn.addEventListener('click', async () => { console.log('Clearing filter.'); try { const response = await fetch('/api/media/filter_config', { method: 'DELETE' }); const result = await response.json(); if (response.ok) { filterFunctionInput.value = ''; filterStatusDiv.textContent = 'Filter cleared successfully!'; filterStatusDiv.style.color = 'green'; console.log('Filter cleared successfully via API.'); clearSelectionsAndUndoHistory(); fetchMedia(1); } else { filterStatusDiv.textContent = `Error: ${result.error || 'Could not clear filter.'}`; filterStatusDiv.style.color = 'red'; console.error('API error clearing filter:', result.error); } } catch (error) { console.error('Network error clearing filter:', error); filterStatusDiv.textContent = 'Network error clearing filter.'; filterStatusDiv.style.color = 'red'; } });
    document.getElementById('tag-management-btn').onclick = () => openModal('tag-management-modal');

    // Initial Data Load
    fetchMedia(currentPage, currentSortBy, currentSortOrder);
    fetchOrgPaths();
    fetchGlobalTags();

    window.appContext = { refreshPhotoWall: () => fetchMedia(currentPage, currentSortBy, currentSortOrder), clearSelections: clearSelectionsAndUndoHistory };
});
