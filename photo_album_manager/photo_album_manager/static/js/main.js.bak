document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM fully loaded. Initializing application features.');

    const photoWall = document.getElementById('photo-wall');
    const prevPageBtn = document.getElementById('prev-page');
    const nextPageBtn = document.getElementById('next-page');
    const pageInfoSpan = document.getElementById('page-info');
    const orgPathsList = document.getElementById('org-paths-list');
    const globalTagsList = document.getElementById('global-tags-list');

    let currentPage = 1;
    let totalPages = 1;
    let photosPerRow = parseInt(document.getElementById('size-input').value) || 5;
    let currentSortBy = document.getElementById('sort-by').value;
    let currentSortOrder = document.getElementById('sort-order').value;

    const selectedMediaIds = new Set();
    let currentMediaItems = []; // To store the list of media items for current view (for original image viewer)

    async function fetchMedia(page = 1, perPage = 20, sortBy = 'capture_time', sortOrder = 'desc') {
        try {
            // Adjust perPage based on photosPerRow and a guess of rows, e.g., 4 rows
            // This part might need refinement based on how 'size-input' truly affects layout vs data fetched
            // For now, perPage will be a fixed reasonably large number to fill some rows.
            // A more sophisticated approach would calculate perPage based on available width/height and thumbnail size.
            const calculatedPerPage = photosPerRow * 4; // Example: 5 items/row * 4 rows = 20 items

            const response = await fetch(`/api/media?page=${page}&per_page=${calculatedPerPage}&sort_by=${sortBy}&sort_order=${sortOrder}`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            renderPhotoWall(data.media);
            currentPage = data.current_page;
            totalPages = data.total_pages;
            currentMediaItems = data.media; // Store for viewer
            updatePaginationControls();
        } catch (error) {
            console.error('Error fetching media:', error);
            photoWall.innerHTML = '<p>Error loading media. Please try again.</p>';
        }
    }

    function renderPhotoWall(mediaItems) {
        photoWall.innerHTML = ''; // Clear existing photos
        if (!mediaItems || mediaItems.length === 0) {
            photoWall.innerHTML = '<p>No media found.</p>';
            return;
        }

        const thumbSize = Math.floor((photoWall.clientWidth - (photosPerRow -1) * 10) / photosPerRow) - 4; // Account for gap & border

        mediaItems.forEach(item => {
            const thumbItem = document.createElement('div');
            thumbItem.classList.add('thumbnail-item');
            thumbItem.dataset.id = item.id;
            thumbItem.style.width = `${thumbSize}px`;
            thumbItem.style.height = `${thumbSize}px`;
            thumbItem.style.backgroundImage = `url(/api/media/thumbnail/${item.id})`;

            if (selectedMediaIds.has(item.id)) {
                thumbItem.classList.add('selected');
            }

            // Left-click to select/deselect
            thumbItem.addEventListener('click', (event) => {
                if (event.shiftKey || event.key === 'x') { // Shift or 'x' key for opening viewer
                    // This is handled by the second click listener to prioritize viewer opening
                    return;
                }
                toggleSelection(thumbItem, item.id);
            });

            // Viewer opening click listener (can be combined or prioritized)
            // Using a separate listener to make logic clear, could be merged with selection click
            thumbItem.addEventListener('click', (event) => {
                if (event.shiftKey || event.key === 'x') { // Shift or 'x' key for opening viewer for now
                    event.preventDefault(); // Prevent other click actions like selection
                    openImageViewer(item.id);
                }
            });

            photoWall.appendChild(thumbItem);
        });
    }

    function toggleSelection(thumbElement, mediaId) {
        if (selectedMediaIds.has(mediaId)) {
            selectedMediaIds.delete(mediaId);
            thumbElement.classList.remove('selected');
        } else {
            selectedMediaIds.add(mediaId);
            thumbElement.classList.add('selected');
        }
        console.log('Selected IDs:', Array.from(selectedMediaIds));
    }

    function updatePaginationControls() {
        pageInfoSpan.textContent = `Page ${currentPage} of ${totalPages}`;
        prevPageBtn.disabled = currentPage <= 1;
        nextPageBtn.disabled = currentPage >= totalPages;
    }

    async function fetchOrgPaths() {
        try {
            const response = await fetch('/api/org_paths');
            const data = await response.json();
            orgPathsList.innerHTML = '';
            data.forEach(path => {
                const li = document.createElement('li');
                li.textContent = path;
                orgPathsList.appendChild(li);
            });
        } catch (error) {
            console.error('Error fetching org paths:', error);
        }
    }

    async function fetchGlobalTags() {
        try {
            const response = await fetch('/api/tags');
            const data = await response.json();
            globalTagsList.innerHTML = '';
            data.forEach(tag => {
                const li = document.createElement('li');
                li.textContent = tag.name;
                li.dataset.tagId = tag.id;
                // Add click listener for tag selection/activation later (feature 2.2)
                globalTagsList.appendChild(li);
            });
        } catch (error) {
            console.error('Error fetching global tags:', error);
        }
    }

    // Event Listeners for Pagination
    prevPageBtn.addEventListener('click', () => {
        if (currentPage > 1) fetchMedia(currentPage - 1, undefined, currentSortBy, currentSortOrder);
    });
    nextPageBtn.addEventListener('click', () => {
        if (currentPage < totalPages) fetchMedia(currentPage + 1, undefined, currentSortBy, currentSortOrder);
    });

    // Initial Data Load
    fetchMedia(currentPage, undefined, currentSortBy, currentSortOrder);
    fetchOrgPaths();
    fetchGlobalTags();

    // Modal handling (from previous step, slightly refined)
    const modals = document.querySelectorAll('.modal');
    const closeButtons = document.querySelectorAll('.close-modal-btn');

    function openModal(modalId) {
        const modal = document.getElementById(modalId);
        if(modal) modal.style.display = 'block';
    }

    function closeModal(modalElement) {
        modalElement.style.display = 'none';
    }

    closeButtons.forEach(button => {
        button.onclick = function() {
            closeModal(button.closest('.modal'));
        }
    });

    window.onclick = function(event) {
        modals.forEach(modal => {
            if (event.target == modal) {
                closeModal(modal);
            }
        });
    }
    // Expose openModal globally if needed for inline event handlers, or bind specific buttons
    // window.openModal = openModal;

    const imageViewerModal = document.getElementById('image-viewer-modal');
    const fullImage = document.getElementById('full-image');
    const modalCaption = document.querySelector('.modal-caption');
    const modalPrev = document.querySelector('.modal-prev');
    const modalNext = document.querySelector('.modal-next');
    let currentViewIndex = -1;

    function openImageViewer(mediaId) {
        const itemIndex = currentMediaItems.findIndex(m => m.id === mediaId);
        if (itemIndex === -1) return;
        currentViewIndex = itemIndex;
        updateImageViewerContent();
        openModal('image-viewer-modal');
    }

    function updateImageViewerContent() {
        if (currentViewIndex < 0 || currentViewIndex >= currentMediaItems.length) return;
        const item = currentMediaItems[currentViewIndex];
        fullImage.src = `/api/media/file/${item.id}`;
        modalCaption.textContent = item.filename;
        modalPrev.style.display = currentViewIndex > 0 ? 'block' : 'none';
        modalNext.style.display = currentViewIndex < currentMediaItems.length - 1 ? 'block' : 'none';
    }

    modalPrev.onclick = () => { if(currentViewIndex > 0) { currentViewIndex--; updateImageViewerContent(); }};
    modalNext.onclick = () => { if(currentViewIndex < currentMediaItems.length - 1) { currentViewIndex++; updateImageViewerContent(); }};

    document.addEventListener('keydown', (event) => {
        if (imageViewerModal.style.display === 'block') {
            if (event.key === 'ArrowLeft' && currentViewIndex > 0) {
                currentViewIndex--;
                updateImageViewerContent();
            } else if (event.key === 'ArrowRight' && currentViewIndex < currentMediaItems.length - 1) {
                currentViewIndex++;
                updateImageViewerContent();
            } else if (event.key === 'Escape') {
                closeModal(imageViewerModal);
            }
        }
    });

    // Hook up modal trigger buttons
    document.getElementById('filter-config-btn').onclick = () => openModal('filter-config-modal');
    document.getElementById('tag-management-btn').onclick = () => openModal('tag-management-modal');

    // Make fetchMedia globally available for other functions to call if needed, or pass as callback
    window.refreshPhotoWall = () => fetchMedia(currentPage, undefined, currentSortBy, currentSortOrder);
    window.updateSortCriteria = (newSortBy, newSortOrder) => {
        currentSortBy = newSortBy;
        currentSortOrder = newSortOrder;
    };
    window.updatePhotosPerRow = (newPhotosPerRow) => {
        photosPerRow = newPhotosPerRow;
    };
});
