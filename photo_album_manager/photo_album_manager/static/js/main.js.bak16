document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM fully loaded. Initializing application features. Implementing tag activation.');

    // Cache DOM elements
    const photoWall = document.getElementById('photo-wall');
    const prevPageBtn = document.getElementById('prev-page');
    const nextPageBtn = document.getElementById('next-page');
    const pageInfoSpan = document.getElementById('page-info');
    const orgPathsList = document.getElementById('org-paths-list');
    const globalTagsListUl = document.getElementById('global-tags-list'); // Renamed for clarity (UL element)
    const sizeInput = document.getElementById('size-input');
    const sortBySelect = document.getElementById('sort-by');
    const sortOrderSelect = document.getElementById('sort-order');
    const refreshBtn = document.getElementById('refresh-btn');
    const filterConfigBtn = document.getElementById('filter-config-btn');
    const filterConfigModal = document.getElementById('filter-config-modal');
    const filterFunctionInput = document.getElementById('filter-function-input');
    const applyFilterBtn = document.getElementById('apply-filter-btn');
    const clearFilterBtn = document.getElementById('clear-filter-btn');
    const filterStatusDiv = document.getElementById('filter-status');
    const tagManagementBtn = document.getElementById('tag-management-btn');
    const tagManagementModal = document.getElementById('tag-management-modal');
    const newTagInput = document.getElementById('new-tag-input');
    const addNewTagBtn = document.getElementById('add-new-tag-btn');
    const manageTagsListUl = document.getElementById('manage-tags-list');
    const tagManagementStatusDiv = document.getElementById('tag-management-status');
    const imageViewerModal = document.getElementById('image-viewer-modal');
    const fullImage = document.getElementById('full-image');
    const modalCaption = document.querySelector('.modal-caption');
    const modalPrev = document.querySelector('.modal-prev');
    const modalNext = document.querySelector('.modal-next');

    // Application State
    let currentPage = 1, totalPages = 1;
    let photosPerRow = parseInt(sizeInput.value) || 5;
    photoWall.style.setProperty('--photos-per-row', photosPerRow);
    let currentSortBy = sortBySelect.value, currentSortOrder = sortOrderSelect.value;
    const selectedMediaIds = new Set();
    const activeTagNamesForOperations = new Set(); // To store names of active tags
    let currentMediaItems = [], isXKeyPressed = false, resizeTimeout, lastCalculatedPerPage = 0;

    document.addEventListener('keydown', (event) => { if (event.key === 'x' || event.key === 'X') isXKeyPressed = true; });
    document.addEventListener('keyup', (event) => { if (event.key === 'x' || event.key === 'X') isXKeyPressed = false; });

    // --- Minified/Unchanged Core Functions for brevity ---
    function getCalculatedPerPage() { console.log('[getCalculatedPerPage] Starting calculation...');const currentPhotosPerRowVal=parseInt(photoWall.style.getPropertyValue('--photos-per-row'))||photosPerRow;const wallWidth=photoWall.clientWidth;const availableHeight=photoWall.parentElement?photoWall.parentElement.clientHeight:window.innerHeight;const gap=10;console.log(`[getCalculatedPerPage] currentPhotosPerRowVal: ${currentPhotosPerRowVal}`);console.log(`[getCalculatedPerPage] wallWidth: ${wallWidth}, availableHeight (content-area): ${availableHeight}, gap: ${gap}`);if(wallWidth===0||availableHeight===0||currentPhotosPerRowVal===0){console.warn('[getCalculatedPerPage] Wall dimensions, availableHeight or photosPerRow is zero. Defaulting perPage.');return currentPhotosPerRowVal>0?currentPhotosPerRowVal*4:20}const columnWidth=(wallWidth-(currentPhotosPerRowVal-1)*gap)/currentPhotosPerRowVal;console.log(`[getCalculatedPerPage] columnWidth: ${columnWidth.toFixed(2)}`);const thumbHeight=columnWidth;console.log(`[getCalculatedPerPage] thumbHeight (equal to columnWidth): ${thumbHeight.toFixed(2)}`);const singleRowTotalHeight=thumbHeight+gap;console.log(`[getCalculatedPerPage] singleRowTotalHeight (thumbHeight + gap): ${singleRowTotalHeight.toFixed(2)}`);if(singleRowTotalHeight<=gap){console.warn('[getCalculatedPerPage] singleRowTotalHeight is too small (<= gap). Defaulting numRows to 1, perPage to photosPerRow.');return currentPhotosPerRowVal}const numRows=Math.max(1,Math.floor(availableHeight/singleRowTotalHeight));console.log(`[getCalculatedPerPage] Calculated numRows: ${numRows} (based on availableHeight ${availableHeight} / singleRowTotalHeight ${singleRowTotalHeight.toFixed(2)})`);const calculatedPerPage=currentPhotosPerRowVal*numRows;console.log(`[getCalculatedPerPage] Initial calculatedPerPage (photosPerRow * numRows): ${calculatedPerPage}`);const finalPerPage=Math.max(currentPhotosPerRowVal,calculatedPerPage);console.log(`[getCalculatedPerPage] Final perPage to return: ${finalPerPage}`);return finalPerPage }
    async function fetchMedia(page = 1, sortBy = currentSortBy, sortOrder = currentSortOrder) { if(photoWall)void photoWall.offsetHeight;const calculatedPerPage=getCalculatedPerPage();lastCalculatedPerPage=calculatedPerPage;const apiUrl=`/api/media?page=${page}&per_page=${calculatedPerPage}&sort_by=${sortBy}&sort_order=${sortOrder}`;console.log(`Fetching media from: ${apiUrl}`);try{const response=await fetch(apiUrl);if(!response.ok)throw new Error(`HTTP error! status: ${response.status}, message: ${await response.text()}`);const data=await response.json();console.log('Received media data:',{currentPage:data.current_page,totalPages:data.total_pages,totalItems:data.total_items,itemsInPage:data.media.length});currentMediaItems=data.media;renderPhotoWall(currentMediaItems);currentPage=data.current_page;totalPages=data.total_pages;updatePaginationControls()}catch(error){console.error('Error fetching media:',error);photoWall.innerHTML=`<p>Error loading media: ${error.message}. Please try again.</p>`} }
    function renderPhotoWall(mediaItems) { console.log(`Rendering photo wall with ${mediaItems?mediaItems.length:0} items.`);photoWall.innerHTML='';if(!mediaItems||mediaItems.length===0){photoWall.innerHTML='<p>No media found matching your criteria.</p>';return}console.log(`Photo wall using CSS Grid with '--photos-per-row': ${photoWall.style.getPropertyValue('--photos-per-row')}`);mediaItems.forEach(item=>{const thumbItem=document.createElement('div');thumbItem.classList.add('thumbnail-item');thumbItem.dataset.id=item.id;thumbItem.style.backgroundImage=`url(/api/media/thumbnail/${item.id})`;if(selectedMediaIds.has(item.id))thumbItem.classList.add('selected');thumbItem.addEventListener('click',(event)=>{if(isXKeyPressed){event.preventDefault();openImageViewer(item.id)}else{toggleSelection(thumbItem,item.id)}});photoWall.appendChild(thumbItem)}) }
    function toggleSelection(thumbElement, mediaId) { if(selectedMediaIds.has(mediaId)){selectedMediaIds.delete(mediaId);thumbElement.classList.remove('selected')}else{selectedMediaIds.add(mediaId);thumbElement.classList.add('selected')}console.log('Current selection IDs:',Array.from(selectedMediaIds)) }
    function updatePaginationControls() { pageInfoSpan.textContent=`Page ${currentPage} of ${totalPages}`;prevPageBtn.disabled=currentPage<=1;nextPageBtn.disabled=currentPage>=totalPages }
    async function fetchOrgPaths() { try{const r=await fetch('/api/org_paths');const d=await r.json();orgPathsList.innerHTML='';d.forEach(p=>{const l=document.createElement('li');l.textContent=p;orgPathsList.appendChild(l)})}catch(e){console.error('Error fetching org paths:',e)} }

    // --- Global Tags List in Info Panel (for display and activation) ---
    async function fetchGlobalTags() {
        console.log('[InfoPanel] Fetching global tags for info panel...');
        if (!globalTagsListUl) {
            console.error("[InfoPanel] globalTagsListUl element not found.");
            return;
        }
        try {
            const response = await fetch('/api/tags');
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP error! Status: ${response.status}, Message: ${errorText}`);
            }
            const tags = await response.json();
            globalTagsListUl.innerHTML = ''; // Clear existing list
            if (tags.length === 0) {
                globalTagsListUl.innerHTML = '<li>No tags defined.</li>';
            } else {
                tags.forEach(tag => {
                    const li = document.createElement('li');
                    li.textContent = tag.name;
                    li.dataset.tagId = tag.id;
                    li.dataset.tagName = tag.name; // Store name for easy access

                    // Check if this tag is in the active set and apply class if so
                    if (activeTagNamesForOperations.has(tag.name)) {
                        li.classList.add('active-for-tagging');
                    }

                    li.addEventListener('click', () => {
                        if (activeTagNamesForOperations.has(tag.name)) {
                            activeTagNamesForOperations.delete(tag.name);
                            li.classList.remove('active-for-tagging');
                        } else {
                            activeTagNamesForOperations.add(tag.name);
                            li.classList.add('active-for-tagging');
                        }
                        console.log('[InfoPanel] Active tags for operations:', Array.from(activeTagNamesForOperations));
                    });
                    globalTagsListUl.appendChild(li);
                });
            }
            console.log('[InfoPanel] Global tags list populated/updated.');
        } catch (error) {
            console.error('Error fetching/rendering global tags for info panel:', error);
            globalTagsListUl.innerHTML = `<li>Error loading tags: ${error.message}</li>`;
        }
    }

    // --- Tag Management Modal: Populate List, Add Tag, Delete Tag ---
    async function handleDeleteTag(tagId, tagName) { console.log(`[TagManagement] Attempting to delete tag: ID=${tagId}, Name='${tagName}'`);if(!confirm(`Are you sure you want to delete the tag '${tagName}'? This will remove it from all photos.`)){console.log('[TagManagement] Deletion cancelled by user.');tagManagementStatusDiv.textContent='Deletion cancelled.';tagManagementStatusDiv.style.color='gray';return}tagManagementStatusDiv.textContent='Deleting tag...';tagManagementStatusDiv.style.color='orange';try{const response=await fetch(`/api/tags/${tagId}`,{method:'DELETE'});const result=await response.json();if(response.ok){tagManagementStatusDiv.textContent=result.message||`Tag '${tagName}' deleted successfully.`;tagManagementStatusDiv.style.color='green';populateManageTagsList();fetchGlobalTags();window.appContext.refreshPhotoWall()}else{tagManagementStatusDiv.textContent=`Error: ${result.error||'Could not delete tag.'}`;tagManagementStatusDiv.style.color='red'}}catch(error){console.error('[TagManagement] Error deleting tag:',error);tagManagementStatusDiv.textContent='Network error or server issue deleting tag.';tagManagementStatusDiv.style.color='red'} }
    async function populateManageTagsList() { console.log('[TagManagement] Populating manage tags list...');if(!manageTagsListUl)return;tagManagementStatusDiv.textContent='Loading tags...';tagManagementStatusDiv.style.color='gray';try{const response=await fetch('/api/tags');if(!response.ok){const errorText=await response.text();throw new Error(`HTTP error! Status: ${response.status}, Message: ${errorText}`)}const tags=await response.json();manageTagsListUl.innerHTML='';if(tags.length===0)manageTagsListUl.innerHTML='<li>No tags defined yet.</li>';tags.forEach(tag=>{const li=document.createElement('li');const tagNameSpan=document.createElement('span');tagNameSpan.textContent=tag.name;li.appendChild(tagNameSpan);li.dataset.tagId=tag.id;const deleteBtn=document.createElement('button');deleteBtn.textContent='Delete';deleteBtn.style.marginLeft='10px';deleteBtn.style.padding='3px 6px';deleteBtn.style.fontSize='0.8em';deleteBtn.style.backgroundColor='#dc3545';deleteBtn.style.color='white';deleteBtn.style.border='none';deleteBtn.style.cursor='pointer';deleteBtn.onclick=(event)=>{event.stopPropagation();handleDeleteTag(tag.id,tag.name)};li.appendChild(deleteBtn);manageTagsListUl.appendChild(li)});if(tagManagementStatusDiv.textContent==='Loading tags...'){tagManagementStatusDiv.textContent=''}console.log('[TagManagement] Manage tags list populated.')}catch(error){console.error('Error populating manage tags list:',error);manageTagsListUl.innerHTML='<li>Error loading tags.</li>';tagManagementStatusDiv.textContent=`Error loading tags: ${error.message}`;tagManagementStatusDiv.style.color='red'} }
    if(addNewTagBtn){addNewTagBtn.addEventListener('click', async () => { const tagName=newTagInput.value.trim();console.log(`[TagManagement] 'Add Tag' button clicked. Tag name: '${tagName}'`);if(!tagManagementStatusDiv)return;tagManagementStatusDiv.textContent='';tagManagementStatusDiv.style.color='';if(!tagName){tagManagementStatusDiv.textContent='Tag name cannot be empty.';tagManagementStatusDiv.style.color='red';return}tagManagementStatusDiv.textContent='Adding tag...';tagManagementStatusDiv.style.color='orange';try{const response=await fetch('/api/tags',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({name:tagName})});const result=await response.json();if(response.ok){tagManagementStatusDiv.textContent=`Tag '${result.name}' processed successfully.`;tagManagementStatusDiv.style.color='green';newTagInput.value='';populateManageTagsList();fetchGlobalTags()}else{tagManagementStatusDiv.textContent=`Error: ${result.error||'Could not add tag.'}`;tagManagementStatusDiv.style.color='red'}}catch(error){console.error('[TagManagement] Error adding tag:',error);tagManagementStatusDiv.textContent='Network error or server issue adding tag.';tagManagementStatusDiv.style.color='red'} });}

    // --- Event Listeners for Menu Controls & Modals (rest are largely unchanged) ---
    sizeInput.addEventListener('change', () => { const newSize=parseInt(sizeInput.value);if(newSize>0){console.log(`Size changed to ${newSize} photos per row.`);photosPerRow=newSize;photoWall.style.setProperty('--photos-per-row',photosPerRow);clearSelectionsAndUndoHistory();fetchMedia(1)}else{sizeInput.value=photosPerRow} });
    sortBySelect.addEventListener('change', () => { currentSortBy=sortBySelect.value;console.log(`Sort by changed to: ${currentSortBy}`);clearSelectionsAndUndoHistory();fetchMedia(1) });
    sortOrderSelect.addEventListener('change', () => { currentSortOrder=sortOrderSelect.value;console.log(`Sort order changed to: ${currentSortOrder}`);clearSelectionsAndUndoHistory();fetchMedia(1) });
    refreshBtn.addEventListener('click', async () => { console.log('Deep Refresh button clicked.');const o=refreshBtn.textContent;refreshBtn.textContent='Scanning Libraries...';refreshBtn.disabled=true;let s=false;try{const r=await fetch('/api/scan/trigger',{method:'POST'});const t=await r.json().catch(()=>({error:"Failed to parse response JSON."}));if(!r.ok){console.error('Error triggering scan:',t.error,t.details);alert(`Error triggering library scan: ${t.error||'Unknown error'}`);s=true}else{console.log('Library scan triggered successfully via API.');alert('Library scan complete. Refreshing view.')}}catch(e){console.error('Network error or other issue triggering scan:',e);alert('Failed to trigger library scan. Check network or server console.');s=true}refreshBtn.textContent=o;refreshBtn.disabled=false;if(!s){console.log('Scan successful or error handled, proceeding to refresh view data.');clearSelectionsAndUndoHistory();fetchMedia(1,currentSortBy,currentSortOrder);fetchOrgPaths();fetchGlobalTags();if(tagManagementModal && tagManagementModal.style.display==='block'){populateManageTagsList()}} });
    prevPageBtn.addEventListener('click', () => { if(currentPage>1){console.log('Previous page requested.');clearSelectionsAndUndoHistory();fetchMedia(currentPage-1)} });
    nextPageBtn.addEventListener('click', () => { if(currentPage<totalPages){console.log('Next page requested.');clearSelectionsAndUndoHistory();fetchMedia(currentPage+1)} });

    function clearSelectionsAndUndoHistory() {
        selectedMediaIds.clear();
        activeTagNamesForOperations.clear(); // Clear active tags for operations
        fetchGlobalTags(); // This will re-render the global tags list and remove 'active-for-tagging' class
        console.log("FRONTEND: Selections, active tags, and undo history placeholder cleared.");
        if(document.readyState==='complete'||document.readyState==='interactive')renderPhotoWall(currentMediaItems);
    }

    const allModals = document.querySelectorAll('.modal');
    const closeButtons = document.querySelectorAll('.close-modal-btn');
    function openModal(modalId) { const modal = document.getElementById(modalId); if(modal) modal.style.display = 'block'; }
    function closeModal(modalElement) { if(modalElement) modalElement.style.display = 'none'; }
    closeButtons.forEach(button => { button.onclick = function() { closeModal(button.closest('.modal')); }});
    window.onclick = function(event) { allModals.forEach(modal => { if (event.target == modal) closeModal(modal); }); }
    let currentViewIndex = -1;
    function openImageViewer(mediaId) { const itemIndex=currentMediaItems.findIndex(m=>m.id===mediaId);if(itemIndex===-1)return;currentViewIndex=itemIndex;updateImageViewerContent();openModal('image-viewer-modal') }
    function updateImageViewerContent() { if(currentViewIndex<0||currentViewIndex>=currentMediaItems.length)return;const item=currentMediaItems[currentViewIndex];fullImage.src=`/api/media/file/${item.id}`;modalCaption.textContent=item.filename;modalPrev.style.display=currentViewIndex>0?'block':'none';modalNext.style.display=currentViewIndex<currentMediaItems.length-1?'block':'none' }
    modalPrev.onclick = () => { if(currentViewIndex > 0) { currentViewIndex--; updateImageViewerContent(); }};
    modalNext.onclick = () => { if(currentViewIndex < currentMediaItems.length - 1) { currentViewIndex++; updateImageViewerContent(); }};
    document.addEventListener('keydown', (event) => { if (imageViewerModal.style.display === 'block') { if (event.key === 'ArrowLeft') modalPrev.click(); else if (event.key === 'ArrowRight') modalNext.click(); else if (event.key === 'Escape') closeModal(imageViewerModal); }});
    filterConfigBtn.onclick = () => { console.log('Filter config modal opened.'); filterStatusDiv.textContent = ''; filterStatusDiv.style.color = ''; openModal('filter-config-modal'); };
    applyFilterBtn.addEventListener('click', async () => { const filterCode=filterFunctionInput.value;console.log('Applying filter with code:',filterCode.substring(0,100)+'...');try{const response=await fetch('/api/media/filter_config',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({filter_code:filterCode})});const result=await response.json();if(response.ok){filterStatusDiv.textContent='Filter applied successfully!';filterStatusDiv.style.color='green';closeModal(filterConfigModal);clearSelectionsAndUndoHistory();fetchMedia(1)}else{filterStatusDiv.textContent=`Error: ${result.error||'Could not apply filter.'}`;filterStatusDiv.style.color='red';console.error('API error applying filter:',result.error)}}catch(error){console.error('Network error applying filter:',error);filterStatusDiv.textContent='Network error applying filter.';filterStatusDiv.style.color='red'} });
    clearFilterBtn.addEventListener('click', async () => { console.log('Clearing filter.');try{const response=await fetch('/api/media/filter_config',{method:'DELETE'});const result=await response.json();if(response.ok){filterFunctionInput.value='';filterStatusDiv.textContent='Filter cleared successfully!';filterStatusDiv.style.color='green';clearSelectionsAndUndoHistory();fetchMedia(1)}else{filterStatusDiv.textContent=`Error: ${result.error||'Could not clear filter.'}`;filterStatusDiv.style.color='red';console.error('API error clearing filter:',result.error)}}catch(error){console.error('Error clearing filter:',error);filterStatusDiv.textContent='Network error clearing filter.';filterStatusDiv.style.color='red'} });
    if(tagManagementBtn){tagManagementBtn.onclick = () => { console.log('[TagManagement] Tag management modal opened.'); if(tagManagementStatusDiv)tagManagementStatusDiv.textContent = ''; openModal('tag-management-modal'); populateManageTagsList(); };}

    // Initial Data Load
    fetchMedia(currentPage, currentSortBy, currentSortOrder);
    fetchOrgPaths();
    fetchGlobalTags(); // For info panel & initial active tag state

    window.appContext = {
        refreshPhotoWall: () => fetchMedia(currentPage, currentSortBy, currentSortOrder),
        clearSelections: clearSelectionsAndUndoHistory,
        getActiveTagNames: () => Array.from(activeTagNamesForOperations),
        getSelectedMediaIds: () => Array.from(selectedMediaIds)
    };
});
